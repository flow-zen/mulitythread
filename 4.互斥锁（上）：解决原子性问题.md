一个或者多个操作在CPU执行的过程中不被中断的特性，称为“原子性”。

原子性问题的源头是线程切换，“同一时刻只有一个线程执行”这个条件非常重要，我们称之为互斥。

## 简易锁模型
<img width="642" height="531" alt="image" src="https://github.com/user-attachments/assets/c65a5014-317f-4909-968d-ae6364aaf391" />

我们把一段需要互斥执行的代码称为临界区。线程在进入临界区之前，首先尝试加锁lock()，如果成功，则进入临界区，此时我们称这个线程持有锁；否则呢就等待，直到持有锁的线程解锁；持有锁的线程执行完临界区的代码后，执行解锁unlock()。

## 改进后的锁模型
**“锁必须一对一地罩住资源，否则就形同虚设。”**  
Java 里最容易“罩错”的场景就是把 `this` 当锁，却保护着**别的**对象。下面用两个正反例让你一眼看出“资源-锁”对应关系的重要性。

--------------------------------------------------
一、Bug 版：锁了“自家门”，保护“他家资产”
```java
class Account {
    private int balance;          // 受保护资源 R
    private final Object lock = new Object(); // 专属锁 LR

    void transfer(Account target, int amt){
        synchronized (this) {     // ❌ 只锁了“自己”
            balance -= amt;
            target.balance += amt; // 对方 balance 也在临界区，却没用同一把锁！
        }
    }
}
```
- 线程 1：a→b 转账  
- 线程 2：b→c 转账  
两条线程同时改 `b.balance`，一个用 `a.this` 当锁，一个用 `b.this` 当锁，**没有互斥**，结果**丢更新**。

--------------------------------------------------
二、改进版：资源-锁一一对应
```java
class Account {
    private int balance;
    // 静态全局锁，罩住“所有账户”这一资源集合
    private static final Object globalLock = new Object();

    void transfer(Account target, int amt){
        synchronized (globalLock) {  // ✅ 一把锁罩住整个临界区
            balance -= amt;
            target.balance += amt;
        }
    }
}
```
此时无论多少账户并发转账，**同一时刻只有一个线程能进入临界区**，`balance` 的所有读写都被 `globalLock` 串行化，数据正确。

--------------------------------------------------
三、进阶版：粒度细化，但**资源-锁仍保持对应**
```java
void transfer(Account target, int amt){
    // 按账户序号定锁顺序，避免死锁，但核心思想不变：
    // “参与转账的两个账户”是本次受保护资源，必须被**同一把或成对锁**罩住
    Account first  = this.hashCode() < target.hashCode() ? this : target;
    Account second = this.hashCode() < target.hashCode() ? target : this;
    synchronized (first) {
        synchronized (second) {
            this.balance -= amt;
            target.balance += amt;
        }
    }
}
```
虽然锁粒度变细，但**资源与锁的对应关系始终清晰**：  
受保护资源 R = {this.balance, target.balance}  
锁 LR = {first, second}，且成对使用，绝不“锁 A 护 B”。

--------------------------------------------------

Java语言提供的锁技术：synchronized
锁是一种通用的技术方案，Java语言提供的synchronized关键字，就是锁的一种实现。synchronized关键字可以用来修饰方法，也可以用来修饰代码块，它的使用示例基本上都是下面这个样子：
```java
class X {
  // 修饰非静态方法
  synchronized void foo() {
    // 临界区
  }
  // 修饰静态方法
  synchronized static void bar() {
    // 临界区
  }
  // 修饰代码块
  Object obj = new Object()；
  void baz() {
    synchronized(obj) {
      // 临界区
    }
  }
}  
```

当修饰静态方法的时候，锁定的是当前类的Class对象，在上面的例子中就是Class X；- 当修饰非静态方法的时候，锁定的是当前实例对象this。
```java
class SafeCalc {
  long value = 0L;
  long get() {
    return value;
  }
  synchronized void addOne() {
    value += 1;
  }
}
```
首先可以肯定，被synchronized修饰后，无论是单核CPU还是多核CPU，只有一个线程能够执行addOne()方法，所以一定能保证原子操作.
管程中锁的规则：对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。
管程，就是我们这里的synchronized（至于为什么叫管程，我们后面介绍），我们知道synchronized修饰的临界区是互斥的，也就是说同一时刻只有一个线程执行临界区的代码；而所谓“对一个锁解锁 Happens-Before 后续对这个锁的加锁”，指的是前一个线程的解锁操作对后一个线程的加锁操作可见，综合Happens-Before的传递性原则，我们就能得出前一个线程在临界区修改的共享变量（该操作在解锁之前），对后续进入临界区（该操作在加锁之后）的线程是可见的。

按照这个规则，如果多个线程同时执行addOne()方法，可见性是可以保证的，也就说如果有1000个线程执行addOne()方法，最终结果一定是value的值增加了1000。
上面的代码转换为我们提到的锁模型，就是下面图示这个样子。get()方法和addOne()方法都需要访问value这个受保护的资源，这个资源用this这把锁来保护。线程要进入临界区get()和addOne()，必须先获得this这把锁，这样get()和addOne()也是互斥的。

<img width="868" height="628" alt="image" src="https://github.com/user-attachments/assets/da00256c-4049-470a-90bc-ba57e19cb5a9" />

